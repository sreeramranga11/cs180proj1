<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CS 180 Project 1: Colorizing Prokudin-Gorskii Plates</title>

  <meta name="description" content="CS180 Project 1: Colorizing Prokudin-Gorskii plates with single-scale and pyramid alignment. Overview, detailed approach, results with offsets, extra examples, and failure analyses." />

  <!-- Fonts & Bootstrap -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --bg:#f7f9fc;
      --surface:#ffffff;
      --ink:#1b2430;
      --muted:#6b7280;
      --border:#e6e9ef;
      --accent:#2563eb;
      --accent-2:#a855f7;
      --chip:#eef2ff;
      --radius:16px;
      --shadow:0 10px 25px rgba(0,22,68,.08), 0 2px 8px rgba(0,22,68,.06);
    }
    html,body { background: var(--bg); color: var(--ink); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    a { color: #0f4fe6; text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* Header */
    .site-header { background: rgba(255,255,255,.85); backdrop-filter: saturate(180%) blur(10px); }
    .site-header .navbar-brand { font-weight:800; letter-spacing:.2px; }
    .hero-gradient { background: radial-gradient(1200px 500px at 15% -10%, #c7d2fe 0%, transparent 50%), radial-gradient(1200px 500px at 90% -15%, #f5d0fe 0%, transparent 50%); }

    /* Sticky TOC */
    .toc { position:fixed; top:92px; left:16px; width:240px; max-height:calc(100vh - 120px); overflow:auto; padding:14px 14px 10px; border-radius:12px; background:var(--surface); border:1px solid var(--border); box-shadow:var(--shadow); }
    .toc .title { font-size:.8rem; letter-spacing:.18em; text-transform:uppercase; color:#94a3b8; margin-bottom:6px; }
    .toc .nav-link { color:#6b7280; padding:.35rem .25rem; position:relative; border-radius:8px; }
    .toc .nav-link:hover { color:var(--ink); background: #f1f5ff; }
    .toc .nav-link.active { color:var(--ink); font-weight:600; }
    .toc .nav-link::after { content:""; position:absolute; left:0; bottom:-2px; height:2px; width:var(--p,0%); background:linear-gradient(90deg,var(--accent),var(--accent-2)); transition:width .2s; border-radius:2px; }

    /* Progress bar */
    .scroll-progress { position:fixed; top:0; left:0; width:100%; height:3px; background:transparent; z-index:9999; }
    .scroll-progress__bar { height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--accent-2)); }

    /* Cards / panels */
    .panel { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow); }
    .panel .hd { padding:16px 20px; border-bottom:1px solid var(--border); font-weight:700; }
    .panel .bd { padding:18px 20px; color:var(--ink); }

    /* Chips */
    .chip { display:inline-flex; align-items:center; gap:.4rem; padding:.35rem .6rem; border-radius:999px; background:var(--chip); border:1px solid #dbe4ff; color:#344a84; font-size:.85rem; }
    .chip i { display:inline-block; width:6px; height:6px; border-radius:50%; background: linear-gradient(90deg,var(--accent),var(--accent-2)); }

    /* Gallery cards */
    .image-card { position:relative; overflow:hidden; border-radius:14px; border:1px solid var(--border); background:#fff; box-shadow: var(--shadow); }
    .image-card img { display:block; width:100%; height:auto; transform: translateZ(0); transition: transform .35s ease; }
    .image-card:hover img { transform: scale(1.025); }
    .overlay-text { position:absolute; left:.6rem; bottom:.6rem; background:rgba(255,255,255,.75); backdrop-filter: blur(3px); color:var(--ink); padding:.3rem .55rem; border-radius:.4rem; font-size:.85rem; border:1px solid rgba(0,0,0,.06); }

    .metric-badge { font-size:.78rem; background:#f5f7ff; border:1px solid var(--border); color:#334155; }

    /* Layout for TOC reserve */
    main { padding-left: 272px; }
    @media (max-width: 992px) { .toc { display:none !important; } main { padding-left: 0; } }

    /* Code blocks */
    code, .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .code { display:block; background:#f6f8ff; border:1px solid var(--border); border-radius:12px; padding:10px 12px; }

    .text-muted-2 { color: var(--muted); }
    .lead-compact { color:#475569; }
  </style>
</head>
<body data-bs-spy="scroll" data-bs-target="#toc-nav" data-bs-offset="100" tabindex="0">

  <!-- Progress -->
  <div class="scroll-progress"><div id="scroll-progress-bar" class="scroll-progress__bar"></div></div>

  <!-- Header -->
  <header class="site-header border-bottom">
    <nav class="navbar navbar-expand-lg navbar-light">
      <div class="container">
        <a class="navbar-brand fw-bold" href="#">CS 180 Project 1</a>
        <div class="ms-auto small text-muted-2">Colorizing Prokudin-Gorskii Plates</div>
      </div>
    </nav>
  </header>

  <!-- TOC -->
  <aside id="toc" class="toc d-none d-lg-block" aria-label="Table of contents">
    <div class="title fw-bold">Contents</div>
    <nav id="toc-nav" class="nav flex-column small">
      <a class="nav-link" href="#overview">Overview</a>
      <a class="nav-link" href="#approach">Approach</a>
      <a class="nav-link" href="#fixes">Key Fixes</a>
      <a class="nav-link" href="#results">Results</a>
      <a class="nav-link" href="#extras">Extra Examples</a>
      <a class="nav-link" href="#reproduce">How to Reproduce</a>
      <a class="nav-link" href="#notes">Notes</a>
    </nav>
  </aside>

  <main>
    <!-- Hero -->
    <section class="py-5 border-bottom hero-gradient">
      <div class="container py-4">
        <div class="row align-items-center">
          <div class="col-lg-9">
            <h1 class="display-6 fw-bold">CS 180 Project 1: Colorizing Prokudin-Gorskii Plates</h1>
            <p class="lead lead-compact mb-3">
              <strong>Brief overview:</strong> I take a single tall grayscale scan with three equal-height plates
              (top→bottom = B, G, R). I split these channels, <em>align G→B and R→B using integer shifts</em>,
              and composite to RGB. For small JPGs I use single-scale exhaustive search; for large TIFs I
              use a coarse-to-fine pyramid. Only compressed JPG results are shown here, no TIFs.
            </p>
            <div class="d-flex flex-wrap gap-2">
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Approach -->
    <section id="approach" class="py-5">
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-lg-9">
            <div class="panel">
              <div class="hd">Detailed Approach</div>
              <div class="bd">
                <p><strong>High-level:</strong> I split the stacked image into <code>b</code>, <code>g</code>, and <code>r</code> channels, then found 2D integer translations that best align <code>g</code> and <code>r</code> to <code>b</code>. The search window for the single-scale version is <code>[-R, R] × [-R, R]</code>. For TIFs, I built a pyramid by 2× average-pooling. I aligned at the coarsest level and refined at each finer level using appropriately smaller windows.</p>
                <ul>
                  <li><strong>Metrics:</strong> 
                    <ul>
                      <li><code>ncc</code>: normalized cross-correlation on intensity.</li>
                      <li><code>ssd</code>: I maximize <code>-SSD</code>.</li>
                      <li><code>edges</code>/<code>edges5</code>: Sobel magnitude (light Gaussian blur for <code>edges5</code>), scored by <code>-SSD</code>; robust when exposures differ by channel.</li>
                      <li><code>auto</code>: I evaluate <code>ncc</code> and <code>edges5</code> fairly by scoring both on a comparable scale and pick the better one.</li>
                    </ul>
                  </li>
                  <li><strong>Border policy:</strong> during scoring I ignore an inner band (<code>--border</code>) to avoid black frames dominating. After shifting, I crop to the common overlap across B/G/R using the <em>applied</em> vectors. This removes wrap-around color edges. A small <code>--pre-crop</code> helps with thick frames.</li>
                  <li><strong>What I tried when things failed:</strong>
                    <ol>
                      <li>Increase <code>--max-radius</code> and confirm via full score grids (debug) if the optimum was clipped.</li>
                      <li>Switch metric to <code>edges5</code> on images with strong exposure differences (e.g., <code>emir.tif</code>).</li>
                      <li>Increase <code>--border</code> (or asymmetric left/right) to down-weight thick black frames.</li>
                      <li>Try a different anchor (<code>--anchor g</code>) and compare the score maps.</li>
                      <li>Use the pyramid path for large shifts in TIFs.</li>
                    </ol>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Key Fixes -->
    <section id="fixes" class="py-5">
      <div class="container">
        <div class="row justify-content-center g-3">
          <div class="col-lg-9">
            <div class="panel">
              <div class="hd">Key Issues & Fixes</div>
              <div class="bd">
                <h6>1) Shift-sign bug → ghosting</h6>
                <p>My search returns where the moving channel <em>is</em> relative to the reference (<code>(dy,dx)</code>). To align it, I <strong>apply</strong> <code>(-dy,-dx)</code>. Using the wrong sign produced double-ghosting; fixing the sign and reporting <em>applied</em> vectors resolved it.</p>
                <h6>2) <code>auto</code> metric fairness (Emir)</h6>
                <p><code>emir.tif</code> has different per-channel exposures; intensity NCC can pick a wrong peak. My <code>auto</code> compares <code>ncc</code> and <code>edges5</code> in their own feature spaces but on a comparable numeric scale, so I don’t bias toward NCC. For batch runs, I still force <code>edges5</code> on TIFs for safety.</p>
                <h6>3) Frames dominating scores</h6>
                <p>Thick black borders can dominate SSD/NCC. I ignore an inner band during scoring and crop the final overlap after shifting. This simple policy was more reliable for me than full automatic frame detection.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Results -->
    <section id="results" class="py-5">
      <div class="container">
        <div class="row justify-content-center mb-3">
          <div class="col-lg-9 d-flex align-items-center justify-content-between">
            <h2 class="h4 fw-bold mb-0">Results on Provided Images</h2>
          </div>
        </div>

        <!-- Gallery Grid -->
        <div id="results-grid" class="row g-4 justify-content-center">
        </div>

        <!-- Offsets table -->
        <div class="row justify-content-center mt-4">
          <div class="col-lg-9">
            <div class="panel">
              <div class="hd">Displacement Vectors (applied)</div>
              <div class="bd">
                <p class="text-muted-2 mb-2">
                  The table lists the <em>applied</em> G→B and R→B shifts (dy, dx). To keep the site lightweight,
                  I only include compressed images from <code>output/</code> (no large TIFs are uploaded).
                </p>
                <div class="table-responsive">
                  <table id="offsets-table" class="table table-sm align-middle">
                    <thead><tr><th>Image</th><th>Method</th><th>G→B (dy, dx)</th><th>R→B (dy, dx)</th></tr></thead>
                    <tbody></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </section>

    <!-- Extra examples -->
    <section id="extras" class="py-5">
      <div class="container">
        <div class="row justify-content-center mb-3">
          <div class="col-lg-9 d-flex align-items-center justify-content-between">
            <h2 class="h4 fw-bold mb-0">Additional Examples (from the Prokudin-Gorskii collection)</h2>
          </div>
        </div>

        <!-- Extras Grid -->
        <div id="extras-grid" class="row g-4 justify-content-center">
          <!-- Extra cards inserted by JS -->
        </div>

        <div class="row justify-content-center mt-4">
          <div class="col-lg-9">
            <div class="panel">
              <div class="hd">Failures & Difficult Images</div>
              <div class="bd">
                <ul class="mb-0">
                  <li><strong>Emir:</strong> per-channel brightness differs significantly; raw-intensity NCC can mis-score. Using <code>edges5</code> (Sobel on a lightly blurred image) focuses on structure and aligns correctly for me.</li>
                  <li><strong>Heavy frames:</strong> when black borders dominate, metrics can chase them. Ignoring an inner band in scoring and cropping the final overlap removed the color bands I often saw at the edges.</li>
                </ul>
              </div>
            </div>
          </div>
        </div>

      </div>
    </section>

    <!-- Reproduce -->
    <section id="reproduce" class="py-5">
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-lg-9">
            <div class="panel">
              <div class="hd">How to Reproduce</div>
              <div class="bd">
                <h6>Single image</h6>
                <ul>
                  <li>Small JPG (single-scale NCC): <code>python proj1_colorizer.py --input data/cathedral.jpg --method single --metric ncc --max-radius 15 --auto-crop</code></li>
                  <li>Large TIF (pyramid + edges): <code>python proj1_colorizer.py --input data/emir.tif --method pyramid --metric edges5 --auto-crop</code></li>
                </ul>
                <h6 class="mt-3">Batch everything</h6>
                <pre class="code mb-0"># TIFs: pyramid + edges5
for f in data/*.tif; do
  [ -e "$f" ] || continue
  python proj1_colorizer.py --input "$f" --method pyramid --metric edges5 --auto-crop \
    --output "output/$(basename "${f%.*}")_color.jpg"
done

# JPGs: single-scale + NCC
for f in data/*.jpg; do
  [ -e "$f" ] || continue
  python proj1_colorizer.py --input "$f" --method single --metric ncc --max-radius 15 --auto-crop \
    --output "output/$(basename "${f%.*}")_color.jpg"
done</pre>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Notes -->
    <section id="notes" class="py-5">
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-lg-9">
            <div class="panel">
              <div class="hd">Notes &amp; Takeaways</div>
              <div class="bd">
                <ul class="mb-0">
                  <li>Exhaustive search + clear visualizations helped me debug failures quickly.</li>
                  <li>I found edge-based features safer than raw intensity when channels differ in exposure.</li>
                  <li>My simplest border policy worked best: ignore during scoring, crop final overlap afterward.</li>
                  <li>Future work I’d like to try: subpixel refinement, corner/feature-based matching, and learned border cropping.</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

  </main>

  <footer class="py-4 border-top bg-white">
    <div class="container text-center small text-muted">
      <span>&copy; <span id="year"></span> · CS 180 Project 1</span>
    </div>
  </footer>

  <!-- Bootstrap -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // Provided dataset (JPGs + TIFs as compressed JPGs)
    const results = [
      // JPGs (single)
      {file:"cathedral_color.jpg", title:"Cathedral (JPG)", method:"single + ncc"},
      {file:"monastery_color.jpg", title:"Monastery (JPG)", method:"single + ncc"},
      {file:"tobolsk_color.jpg",   title:"Tobolsk (JPG)",   method:"single + ncc"},
      // TIFs (pyramid + edges). displayed as compressed JPGs
      {file:"church_color.jpg",    title:"Church (TIF)",    method:"pyramid + edges5"},
      {file:"emir_color.jpg",      title:"Emir (TIF)",      method:"pyramid + edges5"},
      {file:"harvesters_color.jpg",title:"Harvesters (TIF)",method:"pyramid + edges5"},
      {file:"icon_color.jpg",      title:"Icon (TIF)",      method:"pyramid + edges5"},
      {file:"italil_color.jpg",    title:"Italil (TIF)",    method:"pyramid + edges5"},
      {file:"lastochikino_color.jpg", title:"Lastochikino (TIF)", method:"pyramid + edges5"},
      {file:"lugano_color.jpg",    title:"Lugano (TIF)",    method:"pyramid + edges5"},
      {file:"melons_color.jpg",    title:"Melons (TIF)",    method:"pyramid + edges5"},
      {file:"self_portrait_color.jpg", title:"Self Portrait (TIF)", method:"pyramid + edges5"},
      {file:"siren_color.jpg",     title:"Siren (TIF)",     method:"pyramid + edges5"},
      {file:"three_generations_color.jpg", title:"Three Generations (TIF)", method:"pyramid + edges5"}
    ];

    // Additional examples from Prokudin Gorskii collection
    const extras = [
      {file:"extra_example_1_color.jpg", title:"Extra Example 1 (JPG)", method:"single + ncc"},
      {file:"extra_example_2_color.jpg", title:"Extra Example 2 (JPG)", method:"single + ncc"},
      {file:"extra_example_3_color.jpg", title:"Extra Example 3 (JPG)", method:"single + ncc"}
    ];

    // Offsets from batch run. applied G to B, R to B
    const OFFSETS = {
      "church_color.jpg":{"g":[25,4],"r":[58,-4]},
      "emir_color.jpg":{"g":[49,23],"r":[107,40]},
      "harvesters_color.jpg":{"g":[60,17],"r":[123,14]},
      "icon_color.jpg":{"g":[42,17],"r":[90,23]},
      "italil_color.jpg":{"g":[38,22],"r":[77,36]},
      "lastochikino_color.jpg":{"g":[-3,-2],"r":[76,-8]},
      "lugano_color.jpg":{"g":[41,-17],"r":[93,-29]},
      "melons_color.jpg":{"g":[81,10],"r":[178,13]},
      "self_portrait_color.jpg":{"g":[79,30],"r":[176,37]},
      "siren_color.jpg":{"g":[49,-6],"r":[96,-25]},
      "three_generations_color.jpg":{"g":[53,13],"r":[111,10]},
      "cathedral_color.jpg":{"g":[5,2],"r":[12,3]},
      "extra_example_1_color.jpg":{"g":[-3,1],"r":[-4,1]},
      "extra_example_2_color.jpg":{"g":[5,-1],"r":[10,-3]},
      "extra_example_3_color.jpg":{"g":[2,3],"r":[11,6]},
      "monastery_color.jpg":{"g":[-3,2],"r":[3,2]},
      "tobolsk_color.jpg":{"g":[3,3],"r":[6,3]}
    };

    // Render main gallery
    const grid = document.getElementById('results-grid');
    results.forEach(item => {
      const col = document.createElement('div');
      col.className = 'col-12 col-sm-6 col-md-4';
      const off = OFFSETS[item.file];
      const gb = off ? `(${off.g[0]}, ${off.g[1]})` : "—";
      const rb = off ? `(${off.r[0]}, ${off.r[1]})` : "—";
      col.innerHTML = `
        <figure class="image-card">
          <a href="output/${item.file}" target="_blank" rel="noopener">
            <img src="output/${item.file}" alt="${item.title}" loading="lazy">
          </a>
          <figcaption class="overlay-text">${item.title}</figcaption>
        </figure>
        <div class="d-flex justify-content-between align-items-center mt-1">
          <span class="badge metric-badge">${item.method}</span>
          <span class="small text-muted-2">Offsets: G→B ${gb}, R→B ${rb}</span>
        </div>`;
      grid.appendChild(col);
    });

    // Render extras grid with badges + offsets under each card
    const egrid = document.getElementById('extras-grid');
    extras.forEach(item => {
      const col = document.createElement('div');
      col.className = 'col-12 col-sm-6 col-md-4';
      const off = OFFSETS[item.file];
      const gb = off ? `(${off.g[0]}, ${off.g[1]})` : "—";
      const rb = off ? `(${off.r[0]}, ${off.r[1]})` : "—";
      col.innerHTML = `
        <figure class="image-card">
          <a href="output/${item.file}" target="_blank" rel="noopener">
            <img src="output/${item.file}" alt="${item.title}" loading="lazy">
          </a>
          <figcaption class="overlay-text">${item.title}</figcaption>
        </figure>
        <div class="d-flex justify-content-between align-items-center mt-1">
          <span class="badge metric-badge">${item.method}</span>
          <span class="small text-muted-2">Offsets: G→B ${gb}, R→B ${rb}</span>
        </div>`;
      egrid.appendChild(col);
    });

    // Offsets table (results + extras)
    const tbody = document.querySelector('#offsets-table tbody');
    [...results, ...extras].forEach(item => {
      const tr = document.createElement('tr');
      const off = OFFSETS[item.file];
      const gb = off ? `(${off.g[0]}, ${off.g[1]})` : "—";
      const rb = off ? `(${off.r[0]}, ${off.r[1]})` : "—";
      tr.innerHTML = `
        <td>${item.title}</td>
        <td><span class="badge metric-badge">${item.method}</span></td>
        <td>${gb}</td>
        <td>${rb}</td>`;
      tbody.appendChild(tr);
    });

    // Scroll progress + TOC underline animation
    const bar = document.getElementById('scroll-progress-bar');
    function clamp(n,min,max){return Math.max(min,Math.min(max,n));}
    function updateProgress(){
      const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
      const doc = document.documentElement;
      const max = (doc.scrollHeight - window.innerHeight) || 1;
      bar.style.width = (clamp(scrollY/max,0,1)*100).toFixed(2)+'%';
      const offset = 100;
      const linkMap = new Map(Array.from(document.querySelectorAll('#toc-nav a')).map(a => [a.getAttribute('href').slice(1), a]));
      document.querySelectorAll('main section[id]').forEach(sec=>{
        const start = sec.offsetTop - offset;
        const end = start + sec.offsetHeight;
        const p = clamp((scrollY - start)/(end - start), 0, 1);
        const link = linkMap.get(sec.id);
        if (link) link.style.setProperty('--p', (p*100)+'%');
      });
    }
    window.addEventListener('scroll', updateProgress, {passive:true});
    window.addEventListener('resize', updateProgress);
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('year').textContent = new Date().getFullYear();
      updateProgress();
    });
  </script>
</body>
</html>
